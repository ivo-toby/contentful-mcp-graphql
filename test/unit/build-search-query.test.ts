import { describe, it, expect, beforeEach, vi } from 'vitest'\nimport { graphqlHandlers } from '../../src/handlers/graphql-handlers.js'\n\n// Mock the cache functions\nconst mockIsCacheAvailable = vi.fn()\nconst mockGetCachedContentTypeSchema = vi.fn()\n\nvi.mock('../../src/handlers/graphql-handlers.js', async () => {\n  const actual = await vi.importActual('../../src/handlers/graphql-handlers.js')\n  return {\n    ...actual,\n    isCacheAvailable: mockIsCacheAvailable,\n    getCachedContentTypeSchema: mockGetCachedContentTypeSchema,\n  }\n})\n\ndescribe('Build Search Query', () => {\n  beforeEach(() => {\n    vi.clearAllMocks()\n  })\n\n  const mockSchema = {\n    contentType: 'PageArticle',\n    fields: [\n      { name: 'sys', type: 'Sys!', description: 'System fields' },\n      { name: 'title', type: 'String', description: 'Title field' },\n      { name: 'internalName', type: 'String', description: 'Internal name' },\n      { name: 'slug', type: 'String', description: 'URL slug' },\n      { name: 'publishedDate', type: 'DateTime', description: 'Published date' }\n    ]\n  }\n\n  it('should build a search query for a content type', async () => {\n    mockIsCacheAvailable.mockReturnValue(true)\n    mockGetCachedContentTypeSchema.mockReturnValue(mockSchema)\n\n    const result = await graphqlHandlers.buildSearchQuery({\n      contentType: 'PageArticle',\n      searchTerm: 'address'\n    })\n\n    expect(result.isError).toBeFalsy()\n    const queryText = result.content[0].text\n    \n    // Should contain the query structure\n    expect(queryText).toContain('query SearchPageArticle($searchTerm: String!)')\n    expect(queryText).toContain('pageArticleCollection(where: { OR: [')\n    expect(queryText).toContain('{ title_contains: $searchTerm }')\n    expect(queryText).toContain('{ internalName_contains: $searchTerm }')\n    expect(queryText).toContain('{ slug_contains: $searchTerm }')\n    \n    // Should include variables\n    expect(queryText).toContain('\"searchTerm\": \"address\"')\n    \n    // Should list searchable fields\n    expect(queryText).toContain('- title (String)')\n    expect(queryText).toContain('- internalName (String)')\n    expect(queryText).toContain('- slug (String)')\n  })\n\n  it('should handle content type with Collection suffix', async () => {\n    const collectionSchema = {\n      ...mockSchema,\n      contentType: 'PageArticleCollection'\n    }\n    \n    mockIsCacheAvailable.mockReturnValue(true)\n    mockGetCachedContentTypeSchema\n      .mockReturnValueOnce(null) // First call for 'PageArticle'\n      .mockReturnValueOnce(collectionSchema) // Second call for 'PageArticleCollection'\n\n    const result = await graphqlHandlers.buildSearchQuery({\n      contentType: 'PageArticle',\n      searchTerm: 'test'\n    })\n\n    expect(result.isError).toBeFalsy()\n    expect(result.content[0].text).toContain('PageArticleCollection')\n  })\n\n  it('should filter to specific fields when provided', async () => {\n    mockIsCacheAvailable.mockReturnValue(true)\n    mockGetCachedContentTypeSchema.mockReturnValue(mockSchema)\n\n    const result = await graphqlHandlers.buildSearchQuery({\n      contentType: 'PageArticle',\n      searchTerm: 'test',\n      fields: ['title', 'slug']\n    })\n\n    expect(result.isError).toBeFalsy()\n    const queryText = result.content[0].text\n    \n    // Should only include specified fields\n    expect(queryText).toContain('{ title_contains: $searchTerm }')\n    expect(queryText).toContain('{ slug_contains: $searchTerm }')\n    expect(queryText).not.toContain('{ internalName_contains: $searchTerm }')\n  })\n\n  it('should handle cache not available', async () => {\n    mockIsCacheAvailable.mockReturnValue(false)\n\n    const result = await graphqlHandlers.buildSearchQuery({\n      contentType: 'PageArticle',\n      searchTerm: 'test'\n    })\n\n    expect(result.isError).toBe(true)\n    expect(result.content[0].text).toContain('Query builder requires cached metadata')\n  })\n\n  it('should handle content type not found', async () => {\n    mockIsCacheAvailable.mockReturnValue(true)\n    mockGetCachedContentTypeSchema.mockReturnValue(null)\n\n    const result = await graphqlHandlers.buildSearchQuery({\n      contentType: 'NonExistentType',\n      searchTerm: 'test'\n    })\n\n    expect(result.isError).toBe(true)\n    expect(result.content[0].text).toContain('Content type \"NonExistentType\" not found in cache')\n  })\n\n  it('should handle content type with no searchable fields', async () => {\n    const schemaWithNoTextFields = {\n      contentType: 'Asset',\n      fields: [\n        { name: 'sys', type: 'Sys!', description: 'System fields' },\n        { name: 'width', type: 'Int', description: 'Width in pixels' },\n        { name: 'height', type: 'Int', description: 'Height in pixels' }\n      ]\n    }\n\n    mockIsCacheAvailable.mockReturnValue(true)\n    mockGetCachedContentTypeSchema.mockReturnValue(schemaWithNoTextFields)\n\n    const result = await graphqlHandlers.buildSearchQuery({\n      contentType: 'Asset',\n      searchTerm: 'test'\n    })\n\n    expect(result.isError).toBe(true)\n    expect(result.content[0].text).toContain('No searchable text fields found')\n    expect(result.content[0].text).toContain('Available fields: sys, width, height')\n  })\n\n  it('should handle specified fields that are not searchable', async () => {\n    mockIsCacheAvailable.mockReturnValue(true)\n    mockGetCachedContentTypeSchema.mockReturnValue(mockSchema)\n\n    const result = await graphqlHandlers.buildSearchQuery({\n      contentType: 'PageArticle',\n      searchTerm: 'test',\n      fields: ['publishedDate', 'sys'] // Non-searchable fields\n    })\n\n    expect(result.isError).toBe(true)\n    expect(result.content[0].text).toContain('No searchable text fields found')\n  })\n\n  it('should include all scalar fields in selection', async () => {\n    mockIsCacheAvailable.mockReturnValue(true)\n    mockGetCachedContentTypeSchema.mockReturnValue(mockSchema)\n\n    const result = await graphqlHandlers.buildSearchQuery({\n      contentType: 'PageArticle',\n      searchTerm: 'test'\n    })\n\n    expect(result.isError).toBeFalsy()\n    const queryText = result.content[0].text\n    \n    // Should include all scalar fields in the selection\n    expect(queryText).toContain('sys { id }')\n    expect(queryText).toContain('title')\n    expect(queryText).toContain('internalName')\n    expect(queryText).toContain('slug')\n    expect(queryText).toContain('publishedDate')\n  })\n})\n