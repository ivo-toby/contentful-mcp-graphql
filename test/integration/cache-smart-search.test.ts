import { describe, it, expect, beforeEach, vi } from 'vitest'
import {\n  loadContentfulMetadata,\n  graphqlHandlers,\n  getCacheStatus,\n  isCacheAvailable\n} from '../../src/handlers/graphql-handlers.js'\n\n// Mock fetch\nconst mockFetch = vi.fn()\nvi.stubGlobal('fetch', mockFetch)\n\ndescribe('Integration: Cache + Smart Search', () => {\n  beforeEach(() => {\n    vi.clearAllMocks()\n    // Reset module state\n    vi.resetModules()\n  })\n\n  const mockContentTypesResponse = {\n    data: {\n      __schema: {\n        queryType: {\n          fields: [\n            {\n              name: 'pageArticleCollection',\n              description: 'Page Article Collection',\n              type: { kind: 'OBJECT', ofType: { name: 'PageArticleCollection', kind: 'OBJECT' } }\n            }\n          ]\n        }\n      }\n    }\n  }\n\n  const mockPageArticleSchema = {\n    data: {\n      __type: {\n        name: 'PageArticle',\n        description: 'Page Article content type',\n        fields: [\n          { name: 'sys', description: 'System fields', type: { kind: 'NON_NULL', ofType: { name: 'Sys' } } },\n          { name: 'title', description: 'Title field', type: { kind: 'SCALAR', name: 'String' } },\n          { name: 'internalName', description: 'Internal name', type: { kind: 'SCALAR', name: 'String' } },\n        ]\n      }\n    }\n  }\n\n  const mockSearchResponse = {\n    data: {\n      pageArticleCollection: {\n        items: [\n          {\n            sys: { id: '5PmzE2MC9Xx1M3qsuQE2C7' },\n            title: 'How do I update my address?',\n            internalName: 'How do I update my address?'\n          }\n        ]\n      }\n    }\n  }\n\n  it('should complete full workflow: load cache -> smart search', async () => {\n    // Step 1: Load cache\n    mockFetch\n      .mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockContentTypesResponse\n      })\n      .mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockPageArticleSchema\n      })\n\n    await loadContentfulMetadata('test-space', 'master', 'test-token')\n\n    // Verify cache is loaded\n    expect(isCacheAvailable()).toBe(true)\n    const status = getCacheStatus()\n    expect(status.available).toBe(true)\n    expect(status.contentTypesCount).toBe(1)\n    expect(status.schemasCount).toBe(1)\n\n    // Step 2: Perform smart search using cache\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () => mockSearchResponse\n    })\n\n    const searchResult = await graphqlHandlers.smartSearch({\n      query: 'address',\n      spaceId: 'test-space',\n      environmentId: 'master'\n    })\n\n    // Verify search results\n    expect(searchResult.isError).toBeFalsy()\n    const response = JSON.parse(searchResult.content[0].text)\n    \n    expect(response.query).toBe('address')\n    expect(response.results).toHaveLength(1)\n    expect(response.results[0].contentType).toBe('pageArticle')\n    expect(response.results[0].items[0].title).toBe('How do I update my address?')\n\n    // Verify the generated query was correct\n    const lastFetchCall = mockFetch.mock.calls[mockFetch.mock.calls.length - 1]\n    const requestBody = JSON.parse(lastFetchCall[1].body)\n    \n    expect(requestBody.query).toContain('pageArticleCollection')\n    expect(requestBody.query).toContain('title_contains: $searchTerm')\n    expect(requestBody.query).toContain('internalName_contains: $searchTerm')\n    expect(requestBody.variables.searchTerm).toBe('address')\n  })\n\n  it('should work with query builder after cache load', async () => {\n    // Load cache first\n    mockFetch\n      .mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockContentTypesResponse\n      })\n      .mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockPageArticleSchema\n      })\n\n    await loadContentfulMetadata('test-space', 'master', 'test-token')\n\n    // Use query builder\n    const buildResult = await graphqlHandlers.buildSearchQuery({\n      contentType: 'pageArticle',\n      searchTerm: 'address'\n    })\n\n    expect(buildResult.isError).toBeFalsy()\n    const queryText = buildResult.content[0].text\n    \n    expect(queryText).toContain('query SearchPageArticle($searchTerm: String!)')\n    expect(queryText).toContain('pageArticleCollection(where: { OR: [')\n    expect(queryText).toContain('{ title_contains: $searchTerm }')\n    expect(queryText).toContain('{ internalName_contains: $searchTerm }')\n    expect(queryText).toContain('\"searchTerm\": \"address\"')\n  })\n\n  it('should handle cache miss gracefully and fall back to API', async () => {\n    // Don't load cache, so handlers should fall back to API\n    \n    // Mock API responses for listContentTypes fallback\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () => mockContentTypesResponse\n    })\n\n    const result = await graphqlHandlers.listContentTypes({\n      spaceId: 'test-space',\n      environmentId: 'master'\n    })\n\n    expect(result.isError).toBeFalsy()\n    expect(mockFetch).toHaveBeenCalledTimes(1)\n    \n    const response = JSON.parse(result.content[0].text)\n    expect(response.cached).toBeUndefined() // Should not have cached flag\n    expect(response.contentTypes).toHaveLength(1)\n  })\n\n  it('should handle partial cache loading failure', async () => {\n    // Content types load successfully, but schema fails\n    mockFetch\n      .mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockContentTypesResponse\n      })\n      .mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n        text: async () => 'Not Found'\n      })\n\n    await loadContentfulMetadata('test-space', 'master', 'test-token')\n\n    const status = getCacheStatus()\n    expect(status.contentTypesCount).toBe(1)\n    expect(status.schemasCount).toBe(0) // Schema failed to load\n\n    // Smart search should fail because no schemas are available\n    const searchResult = await graphqlHandlers.smartSearch({\n      query: 'test'\n    })\n\n    expect(searchResult.isError).toBeFalsy()\n    const response = JSON.parse(searchResult.content[0].text)\n    expect(response.results).toHaveLength(0) // No results because no searchable schemas\n  })\n\n  it('should demonstrate significant performance improvement', async () => {\n    // Load cache\n    mockFetch\n      .mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockContentTypesResponse\n      })\n      .mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockPageArticleSchema\n      })\n\n    await loadContentfulMetadata('test-space', 'master', 'test-token')\n    \n    // Reset fetch mock to count calls during search\n    mockFetch.mockClear()\n    \n    // Mock search response\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () => mockSearchResponse\n    })\n\n    const startTime = Date.now()\n    await graphqlHandlers.smartSearch({ query: 'address' })\n    const endTime = Date.now()\n\n    // Should only make 1 API call (the search itself)\n    // Without cache, this would require 3 calls:\n    // 1. listContentTypes\n    // 2. getContentTypeSchema for pageArticle\n    // 3. the actual search\n    expect(mockFetch).toHaveBeenCalledTimes(1)\n    \n    // Performance should be fast (this is more of a demonstration)\n    expect(endTime - startTime).toBeLessThan(1000)\n  })\n\n  it('should handle real-world scenario: find address update article', async () => {\n    // This simulates the exact scenario from our conversation\n    \n    const realContentTypesResponse = {\n      data: {\n        __schema: {\n          queryType: {\n            fields: [\n              { name: 'pageArticleCollection', description: 'Page articles', type: { kind: 'OBJECT' } },\n              { name: 'topicCategoryCollection', description: 'Categories', type: { kind: 'OBJECT' } },\n              { name: 'assetCollection', description: 'Assets', type: { kind: 'OBJECT' } }\n            ]\n          }\n        }\n      }\n    }\n\n    const realPageArticleSchema = {\n      data: {\n        __type: {\n          name: 'PageArticle',\n          fields: [\n            { name: 'sys', type: { kind: 'NON_NULL', ofType: { name: 'Sys' } } },\n            { name: 'title', type: { kind: 'SCALAR', name: 'String' } },\n            { name: 'slug', type: { kind: 'SCALAR', name: 'String' } },\n            { name: 'internalName', type: { kind: 'SCALAR', name: 'String' } }\n          ]\n        }\n      }\n    }\n\n    const realSearchResponse = {\n      data: {\n        pageArticleCollection: {\n          items: [\n            {\n              sys: { id: '5PmzE2MC9Xx1M3qsuQE2C7' },\n              title: 'How do I update my address?',\n              slug: 'how-do-i-update-my-address',\n              internalName: 'How do I update my address?'\n            }\n          ]\n        }\n      }\n    }\n\n    // Load cache\n    mockFetch\n      .mockResolvedValueOnce({ ok: true, json: async () => realContentTypesResponse })\n      .mockResolvedValueOnce({ ok: true, json: async () => realPageArticleSchema })\n      .mockResolvedValueOnce({ ok: true, json: async () => ({ data: { __type: null } }) }) // topicCategory\n      .mockResolvedValueOnce({ ok: true, json: async () => ({ data: { __type: null } }) }) // asset\n\n    await loadContentfulMetadata('test-space', 'master', 'test-token')\n\n    // Search for address\n    mockFetch.mockResolvedValueOnce({ ok: true, json: async () => realSearchResponse })\n\n    const result = await graphqlHandlers.smartSearch({ query: 'address' })\n    \n    expect(result.isError).toBeFalsy()\n    const response = JSON.parse(result.content[0].text)\n    \n    // Should find the address update article\n    expect(response.results).toHaveLength(1)\n    expect(response.results[0].contentType).toBe('pageArticle')\n    expect(response.results[0].items[0].id).toBe('5PmzE2MC9Xx1M3qsuQE2C7')\n    expect(response.results[0].items[0].title).toBe('How do I update my address?')\n    \n    // This is exactly what the user was looking for!\n    expect(response.results[0].items[0].slug).toBe('how-do-i-update-my-address')\n  })\n})\n